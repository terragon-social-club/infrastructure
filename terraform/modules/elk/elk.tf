variable "all_droplet_ips" {}
variable "salt_master_droplet_id" {}
variable "salt_master_private_ip_address" {}
variable "salt_master_public_ip_address" {}
variable "autogenerated_ssh_private_key" {}
variable "ssh_keys" {}
variable "image" {}
variable "geoip_license_key" {}
variable "geoip_account_id" {}
variable "kibana_domain" {}
variable "logstash_size" {}
variable "logstash_workers" {}
variable "elasticsearch_workers" {}
variable "elasticsearch_size" {}
variable "kibana_size" {}
variable "heartbeat_size" {}
variable "heartbeat_provisioned" {}
variable "kibana_proxy_size" {}
variable "tld" {}
variable "heartbeat_access_droplet_ids" {
  default = []
}
variable "kibana_proxy_provisioned" {
  default = false
}

module "Logstash" {
  source = "../salt-minion"
  node_count = var.logstash_workers
  provision = var.logstash_workers > 0
  name = "logstash"
  size = var.logstash_size
  domain_id = var.tld
  keys = var.ssh_keys
  image = var.image
  geoip_license_key = var.geoip_license_key
  geoip_account_id = var.geoip_account_id
  
  salt_minion_roles = ["logstash", "elk", "minion"]
  salt_master_droplet_id = var.salt_master_droplet_id
  salt_master_private_ip_address = var.salt_master_private_ip_address
  salt_master_public_ip_address = var.salt_master_public_ip_address
  autogenerated_ssh_private_key = var.autogenerated_ssh_private_key
}

resource "digitalocean_firewall" "beats_to_logstash" {
  name="Beats-To-Logstash"
  droplet_ids = module.Logstash.droplet_ids
  count = module.Logstash.provision ? 1 : 0

  inbound_rule {
    protocol = "tcp"
    port_range = "5044"
    source_addresses = concat(var.all_droplet_ips,
      module.ElasticSearch.salt_minion_private_ip_addresses,
      module.Logstash.salt_minion_private_ip_addresses,
      module.Kibana.salt_minion_private_ip_addresses,
      module.HAProxy.salt_minion_private_ip_addresses)
  }
  
}

resource "digitalocean_firewall" "es_kibana_to_logstash" {
  name="ES-Kibana-To-Logstash"
  droplet_ids = module.Logstash.droplet_ids
  count = module.Logstash.provision ? 1 : 0

  inbound_rule {
    protocol = "tcp"
    port_range = "9600"
    source_addresses = concat(module.Kibana.salt_minion_private_ip_addresses,
                              module.ElasticSearch.salt_minion_private_ip_addresses)
  }
  
}

module "ElasticSearch" {
  source = "../salt-minion"
  node_count = var.elasticsearch_workers
  provision = var.elasticsearch_workers > 0
  name = "elasticsearch"
  size = var.elasticsearch_size
  domain_id = var.tld
  keys = var.ssh_keys
  image = var.image
  
  salt_minion_roles = ["elasticsearch", "elk", "minion"]
  salt_master_droplet_id = var.salt_master_droplet_id
  salt_master_private_ip_address = var.salt_master_private_ip_address
  salt_master_public_ip_address = var.salt_master_public_ip_address
  autogenerated_ssh_private_key = var.autogenerated_ssh_private_key
}

resource "digitalocean_firewall" "logstash_to_elasticsearch" {
  name="Beats-To-ElasticSearch"
  droplet_ids = module.ElasticSearch.droplet_ids
  count = module.ElasticSearch.provision ? 1 : 0

  inbound_rule {
    protocol = "tcp"
    port_range = "9200"
    source_addresses = concat(module.Logstash.salt_minion_private_ip_addresses,
                              module.Heartbeat.salt_minion_private_ip_addresses)
  }
  
}

module "Heartbeat" {
  source = "../salt-minion"
  node_count = var.heartbeat_provisioned ? 1 : 0
  provision = var.heartbeat_provisioned
  name = "heartbeat"
  size = var.heartbeat_size
  domain_id = var.tld
  keys = var.ssh_keys
  image = var.image
  
  salt_minion_roles = ["heartbeat", "elk", "minion"]
  salt_master_droplet_id = var.salt_master_droplet_id
  salt_master_private_ip_address = var.salt_master_private_ip_address
  salt_master_public_ip_address = var.salt_master_public_ip_address
  autogenerated_ssh_private_key = var.autogenerated_ssh_private_key
}

resource "digitalocean_firewall" "heartbeat_http_local" {
  name="Heartbyte-To-Private-Http"
  droplet_ids = var.heartbeat_access_droplet_ids

  inbound_rule {
    protocol = "tcp"
    port_range = "5984" // Really this needs to be 80, 443 also
    source_addresses = module.Heartbeat.salt_minion_private_ip_addresses
  }
  
}

module "Kibana" {
  source = "../salt-minion"
  node_count = (var.elasticsearch_workers > 0) ? 1 : 0
  provision = var.elasticsearch_workers > 0
  name = "kibana"
  size = var.kibana_size
  domain_id = var.tld
  keys = var.ssh_keys
  image = var.image
  
  salt_minion_roles = ["kibana", "elk", "minion"]
  salt_master_droplet_id = var.salt_master_droplet_id
  salt_master_private_ip_address = var.salt_master_private_ip_address
  salt_master_public_ip_address = var.salt_master_public_ip_address
  autogenerated_ssh_private_key = var.autogenerated_ssh_private_key
}

resource "digitalocean_firewall" "kibana_and_es_to_logstash" {
  name="Logstash-Monitoring"
  droplet_ids = module.Logstash.droplet_ids

  inbound_rule {
    protocol = "tcp"
    port_range = "9700"
    source_addresses = concat(module.Kibana.salt_minion_private_ip_addresses, module.ElasticSearch.salt_minion_private_ip_addresses)
  }
  
}

resource "digitalocean_firewall" "kibana_to_elasticsearch" { # Rename to reflect this is all local to ES. Also, no. Should be all to logstash but not ES
  name="Kibana-To-ElasticSearch"
  droplet_ids = module.ElasticSearch.droplet_ids
  count = module.Kibana.provision ? 1 : 0

  inbound_rule {
    protocol = "tcp"
    port_range = "9200"
    source_addresses = ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"]
  }
  
}

module "HAProxy" {
  source = "../salt-minion"
  node_count = (var.kibana_proxy_provisioned) ? 1 : 0
  provision = true
  name = "haproxy-kibana"
  size = var.kibana_proxy_size
  custom_fqdn = var.kibana_domain
  domain_id = var.tld
  keys = var.ssh_keys
  image = var.image
  
  salt_minion_roles = ["kibana", "haproxy", "minion"]
  salt_master_droplet_id = var.salt_master_droplet_id
  salt_master_private_ip_address = var.salt_master_private_ip_address
  salt_master_public_ip_address = var.salt_master_public_ip_address
  autogenerated_ssh_private_key = var.autogenerated_ssh_private_key
}

resource "digitalocean_firewall" "haproxy_to_kibana" {
  name="HAProxy-To-Kibana"
  droplet_ids = module.Kibana.droplet_ids

  inbound_rule {
    protocol = "tcp"
    port_range = "5601"
    source_addresses = ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"]
  }
  
}

resource "digitalocean_firewall" "world_to_haproxy_kibana" {
  name="World-To-HAProxyKibana"
  droplet_ids = module.HAProxy.droplet_ids

  inbound_rule {
    protocol = "tcp"
    port_range = "80"
    source_addresses = ["0.0.0.0/0"]
  }

  inbound_rule {
    protocol = "tcp"
    port_range = "443"
    source_addresses = ["0.0.0.0/0"]
  }
  
}

resource "digitalocean_record" "kibana_frontend" {
  count = var.kibana_proxy_provisioned ? 1 : 0
  domain = var.tld
  type = "A"
  name = var.kibana_domain
  value = module.HAProxy.salt_minion_public_ip_addresses[0]
}
